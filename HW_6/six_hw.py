# Задача 1
# Планеты вращаются вокруг звезд по эллиптическим орбитам.
# Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь
# Напишите функцию find_farthest_orbit(list_of_orbits),
# которая среди списка орбит найдет ту, по которой вращается самая далекая
# планета. Круговые орбиты не учитывайте: вы знаете, что у вашей звезды
# таких планет нет, зато исскуственные спутники были запущены на круговые орбиты
# Результатом функции должен быть кортеж, содержащий длинны полуосей эллипса
# орбиты самой далекой планеты.
# Каждая орбита представляет собой кортеж из пары чисел - полуосей ее элипса.
# Площадь эллипса вычисляется по формуле S = (pi)ab, где a и b - длинны
# полуосей эллипса.
# При решении задачи используйте списочные выражения.
# Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую
# большую площадь эллипса, а затем найти и сам эллипс, имеющий такую площадь.
# Гарантируется, что самая далекая планета ровно одна
# Пример:
# ввод:
# orbit = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))
# вывод: 2.5 10
import math

print("ЗАДАЧА 1")


def find_farthest_orbit(list_of_orbits):
    pi = round(math.pi, 2)
    for i in list_of_orbits:
        if i[0] == i[1]:
            list_of_orbits.remove(i)
    len_orbits = list(map(lambda a: pi * a[0] * a[1], list_of_orbits))
    return list_of_orbits[len_orbits.index(max(len_orbits))]


orbit = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print('\t', *find_farthest_orbit(orbit))

# Задача 2
# Напишите функцию same_by(characteristic, objects),
# которая проверяет, все ли объекты имеют одинаковые значения некоторой
# характеристики, и возвращает True, если это так. Если значение характеристики
# для разных объектов отличается - то False. Для пустого набора объектов,
# функция должна возвращать True. Аргумент characteristic - это функция,
# которая принимает объект и вычисляет его характеристику.
# Пример:
# ввод: values = [0, 2, 10, 6]
# if same_by(lambda x: x % 2, values):
#   print("same")
# else:
#   print("different")
#   вывод: same
# Пример 2:
# ввод: values = [1, 2, 3, 4]
# if same_by(lambda x: x % 2, values):
#   print("same")
# else:
#   print("different")
#   вывод: different
print("ЗАДАЧА 2")


def same_by(characteristic, objects):
    return len(set(map(characteristic, objects))) < 2


def same_or_different(values):
    if same_by(lambda x: x % 2, values):
        print("\tsame")
    else:
        print("\tdifferent")


values_1 = [0, 2, 10, 6]
same_or_different(values_1)
values_2 = [1, 2, 3, 4]
same_or_different(values_2)

# Задача 3
# Вам уже приходилось писать таблицу умножения. Но на этот раз вас попросили
# сделать в плюс к таблице умножения еще и таблицу сложения,
# а так же таблицу возведения в степень.
# Чтобы не копировать один и тот же код и обобщить все три функции до
# единой функции рисования таблиц (бинарных) арифметических операций,
# напишите функцию print_operation_table(operation, num_rows=9, num_columns=9),
# которая принимает в качестве аргумента функцию,
# вычисляющую элемент по номеру строки и столбца.
# Аргументы num_rows и num_columns указывают число строк и столбцов таблицы,
# которые должны быть распечатаны. Нумерация строк и столбцов идет с единицы
# (подумайте, почему не с 0).
# Примечание: бинарной операцией называется любая операция, у которой ровно
# два аргумента, как, например, у операции умножения.
# Пример:
# ввод:
# print_operation_table(lambda x, y: x * y)
print("ЗАДАЧА 3")


def print_operation_table(operation, num_rows=9, num_columns=9):
    for r in range(1, num_rows + 1):
        res = (f'\t{operation(r, c)}' for c in range(1, num_columns + 1))
        print(*res)


print_operation_table(lambda x, y: x * y)
